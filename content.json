{"pages":[{"title":"关于我","text":"QQ： 1179709526TEl： 13993086325MySite: http://pushiji.topWeibo: https://weibo.com/ushijiLofter: https://pushiji.lofter.comYouku: http://i.youku.com/pushijiCSDN: https://blog.csdn.net/pushiji","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"教 育 积石中学系统主页: http://118.182.77.71:126新生注册: http://118.182.77.71:126/se学生管理: http://118.182.77.71:126/sm试卷上传: http://118.182.77.71:126/se网上阅卷: http://118.182.77.71:66成绩上传: http://118.182.77.71:126校讯短信: http://www.edugansu.com","link":"/education/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C++ 连接 MYSQL 数据库","text":"以下是用 C++ 连接 MySQL 数据库的详细过程。 一、下载 MYSQL 数据库二、添加目录与动态链接库 附加包含目录选择你的项目 - 右键 - 属性 -》C++-》常规 -》附加包含目录。在这里添加你所下载 mysql 的 include 文件夹。说明：我们都知道引用第三方库的时候需要用到头文件，一般头文件会在 Include 的文件夹下，因此在你项目最前面 #include”XXX.h” 的时候就可以在该目录下寻找你要引用的头文件了。 添加库目录说明：这里包含的是 lib 库的目录，针对静态库和动态库的问题大家可以自行去搜索一下相关知识点，一般下载下来的第三方库的静态文件放在 lib 目录下，大家应该找到自己对应的 lib 文件夹。 添加动态库文件（libmysql.lib）说明：这里需要添加 mysql 的库文件，因为上一步我们已经添加了库所在的目录，因此在这里可以直接添加现有的库即可。三、系统配置经过以上两步的相关配置，如果运行出错，点击上图中右上角的配置管理器，活动解决方案平台选 X64，并把 MySql lib 文件夹中的 libmysql.dll 拷到项目下的项目所在的 Debug 文件夹中。","link":"/2020/03/03/C++%E8%BF%9E%E6%8E%A5MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"Git 教程 - 删除本地文件或文件夹并同步至远程","text":"删除文件，一种是从工作区（Workspace）手动删除，另一种是用命令删除 。如果文件还是未跟踪状态，直接删除就可以了。否则还需要清除暂存区（Index / Stage）改变，提交至仓库区（Repository）（或版本区），最终同步至远程仓库（Repository）。 主要代码如下： 123git rm fileName or git rm -r mydirgit commit -m &quot;commit message&quot;git push 详细介绍如下： Git 本地数据管理，大概可以分为三个区： 工作区（Working Directory）：是可以直接编辑的地方。 暂存区（Stage/Index）：数据暂时存放的区域。 版本库（commit History）：存放已经提交的数据。 工作区的文件 git add 后到暂存区，暂存区的文件 git commit 后到版本库。 rm 命令 作用： 删除工作区的文件。 执行命令: 1rm file rm 命令只是删除工作区的文件，并没有删除版本库的文件，想要删除版本库文件还要执行下面的命令： 12git add test.txtgit commit -m &quot;delete test&quot; 结果： 删除了工作区和版本库的文件。 git rm 命令 作用： 删除工作区文件，并且将这次删除放入暂存区。 注意： 要删除的文件是没有修改过的，就是说和当前版本库文件的内容相同，否则会出错。 再执行以下命令即可删除版本库文件： 1git commit -m &quot;delete test&quot; 结果： 删除了工作区和版本库的文件。 git rm -f 作用： 删除工作区和暂存区文件，并且将这次删除放入暂存区。 注意： 要删除的文件已经修改过，就是说和当前版本库文件的内容不同。 文件修改过但还没 git add 到暂存区。 123456D:\\test&gt;git rm data.txterror: the following file has local modifications: data.txt(use --cached to keep the file, or -f to force removal)D:\\test&gt; 文件修改过已经 git add 到暂存区。 12345678D:\\test&gt;git add data.txtD:\\test&gt;git rm data.txterror: the following file has changes staged in the index: data.txt(use --cached to keep the file, or -f to force removal)D:\\test&gt; 可见文件修改后不管有没有 git add 到暂存区，使用 git rm 命令删除都会报错。 解决方法 执行删除命令： 1D:\\test&gt;git rm -f data.txt 查看状态（成功删除工作区和暂存区文件，并且将这次删除放入暂存区。）： 123456789D:\\test&gt;git statusOn branch masterYour branch is ahead of 'origin/master' by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: data.txtD:\\test&gt; 然后提交： 12345D:\\test&gt;git commit -m &quot;delete data by -f&quot;[master 8ff2f05] delete data by -f 1 file changed, 1 deletion (-) delete mode 100644 data.txtD:\\test&gt; 成功删除了版本库文件。 结果： 删除了工作区、暂存区和版本库的文件。 git rm –cached 作用： 删除暂存区文件，但保留工作区的文件，并且将这次删除放入暂存区。 执行删除命令： 12git rm --cached filerm file 然后提交： 1git commit -m &quot;commit message&quot; 成功删除了版本库文件。 结果： 删除了暂存区和版本库的文件，但保留了工作区的文件。如果文件有修改并 git add 到暂存区，再执行 git rm –cached 和 git commit，那么保留的工作区文件是修改后的文件，同时暂存区的修改文件和版本库的文件也被删了。","link":"/2020/03/15/Git%E6%95%99%E7%A8%8B-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B9%B6%E5%90%8C%E6%AD%A5%E8%87%B3%E8%BF%9C%E7%A8%8B/"},{"title":"Git 教程 - 把本地仓库推送至远程仓库","text":"以码云为例，介绍如何将本地仓库上传至远程仓库。共有 6 个步骤。 主要代码如下： 123456git initgit add .git commit -m &quot;commit message&quot;git remote add origin https://gitee/com/useName/repositoryName.gitgit pull --rebase origin mastergit push -u origin master 以下为详细内容： git init [folder] 初始化本地仓库，命令行目录切换至本地仓库目录后运行 git init, 或在后面添加本地仓库目录。 Git add git add [参数]&lt; 路径 &gt; 作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉 git 系统，我们要提交哪些文件，之后就可以使用 git commit 命令进行提交了。 git add .“.” 表示当前目录，可以修改。监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改 (modified) 以及新文件 (new)，但不包括被删除的文件。 git add -u .（git add –update .）监控已经被 add 的文件（即 tracked file），会将被修改的文件提交到暂存区。但不会提交新文件（untracked file）。 git add -A .（git add –all .）是上面两个功能的合集。 总结： git add -A 提交所有变化 git add -u 提交被修改 (modified) 和被删除 (deleted) 文件，不包括新文件 (new) git add . 提交新文件 (new) 和被修改 (modified) 文件，不包括被删除 (deleted) 文件 Git commit git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用 git commit 命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id，commit-id 在版本回退的时候是非常有用的，它相当于一个快照，可以在未来的任何时候通过与 git reset 的组合命令回到这里。 git commit -m ‘message’“-m ” 参数表示可以直接输入后面的 “message”，如果不加 - m 参数，那么是不能直接输入 message 的，而是会调用一个编辑器一般是 vim 来让你输入这个 message，message 即是我们用来简要说明这次提交的语句。 git commit -am ‘message’ -am 等同于 - a -m“-a” 参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过 git dd 添加到暂存区。 注意：新加的文件（即没有被 git 系统管理的文件）是不能被提交到本地仓库的。 git remote add origin https_Address 添加远程库，即建立本地仓库与远程仓库关联。 git pull –rebase origin master 在本地仓库生成 “README.md” 和 “README.en.md” 两个文件。 git push git push 的一般形式为 git push &lt; 远程主机名 &gt; &lt; 本地分支名 &gt; &lt; 远程分支名 &gt; ，例如 git push origin master：refs/for/master ，即是将本地的 master 分支推送到远程主机 origin 上的对应 master 分支， origin 是远程主机名，第一个 master 是本地分支名，第二个 master 是远程分支名。 git push origin master如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 git push origin:refs/for/master如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master。 git push origin如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到 origin 主机的对应分支。 git push如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用 git branch -r ，查看远程的分支名。 git push -u origin master如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用 git push。 git push –all origin当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项。 git push –force origingit push 的时候需要本地先 gitpull 更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你 git pull 更新，如果一定要提交，那么可以使用这个命令。 git push origin –tagsgit push 的时候不会推送标签，如果一定要推送标签的话那么可以使用这个命令。","link":"/2020/03/14/Git%E6%95%99%E7%A8%8B-%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"title":"Git 教程 - 撤销工作区文件的修改","text":"git checkout – file其作用是文件在工作区的修改全部撤销，这里有两种情况： 一种是文件自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态； 一种是文件已经添加到暂存区后，又作了修改，撤销修改就回到添加到暂存区后的状态。 总之，这个命令就是让这个文件回到最近一次 git commit 或 git add 时的状态。另外，命令中的 “–” 很重要，没有 “–”，就变成了 “切换到另一个分支” 的命令。git restore –staged 取消暂存（track）。 git reset HEAD 把暂存区的修改撤销掉（unstage），重新放回工作区。 git reset –hard HEAD [~ n]把当前版本回退到上一个或上 n 个版本。 git reset –hard commitID指定回到未来的某个版本。 git reflog查看命令历史。如果想回到未来的某个版本，但已经关掉了命令窗口，那么 git reflog 就可以派上用场了。","link":"/2020/03/15/Git%E6%95%99%E7%A8%8B-%E6%92%A4%E9%94%80%E5%B7%A5%E4%BD%9C%E5%8C%BA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9/"},{"title":"git reset,git restore and git revert","text":"git-reset - Reset current HEAD to the specified state git-restore - Restore working tree files git-revert - Revert some existing commits git reset1234git reset [-q] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​git reset [-q] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [&lt;tree-ish&gt;]git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…​]git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] reset 三种模式–hard：重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容，所以效果看起来等同于清空暂存区和工作区。 –soft：重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中 (Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。 –mixed（默认）：重置位置的同时，只保留 Working Tree 工作目录的內容，但会将 Index 暂存区 和 Repository 中的內容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。 使用场景:–hard：(1) 要放弃目前本地的所有改变時，即去掉所有 add 到暂存区的文件和工作区的文件，可以执行 git reset -hard HEAD 来强制恢复 git 管理的文件夹的內容及状态； (2) 真的想抛弃目标节点后的所有 commit（可能觉得目标节点到原节点之间的 commit 提交都是错了，之前所有的 commit 有问题）。 –soft：原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中 (Staged files)，所以假如我们之前工作目录没有改过任何文件，也没 add 到暂存区，那么使用 reset –soft 后，我们可以直接执行 git commit 將 index 暂存区中的內容提交至 repository 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录 (可能是阶段性地频繁提交，就是开发一个功能的时候，改或者增加一个文件的时候就 commit，这样做导致一个完整的功能可能会好多个 commit 点，这时假如你需要把这些 commit 整合成一个 commit 的时候) 時，可以考虑使用 reset –soft 来让 commit 演进线图较为清晰。总而言之，可以使用 –soft 合并 commit 节点。 –mixed（默认）：(1) 使用完 reset –mixed 后，我們可以直接执行 git add 将這些改变果的文件內容加入 index 暂存区中，再执行 git commit 将 Index 暂存区 中的內容提交至 Repository 中，这样一样可以达到合并 commit 节点的效果（与上面 –soft 合并 commit 节点差不多，只是多了 git add 添加到暂存区的操作）； (2) 移除所有 Index 暂存区中准备要提交的文件 (Staged files)，我们可以执行 git reset HEAD 来 Unstage 所有已列入 Index 暂存区 的待提交的文件。(有时候发现 add 错文件到暂存区，就可以使用命令)。 (3) commit 提交某些错误代码，或者没有必要的文件也被 commit 上去，不想再修改错误再 commit（因为会留下一个错误 commit 点），可以回退到正确的 commit 点上，然后所有原节点和 reset 节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再 commit 上去就 OK 了。 git restore123git restore [&lt;options&gt;] [--source=&lt;tree&gt;] [--staged] [--worktree] [--] &lt;pathspec&gt;…​git restore [&lt;options&gt;] [--source=&lt;tree&gt;] [--staged] [--worktree] --pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]git restore (-p|--patch) [&lt;options&gt;] [--source=&lt;tree&gt;] [--staged] [--worktree] [--] [&lt;pathspec&gt;…​] restore 两种模式git restore 表示将在工作空间但是不在暂存区的文件撤销更改。 git restore –staged 作用是将暂存区的文件从暂存区撤出，但不会更改文件。 git revert12git revert [--[no-] edit] [-n] [-m parent-number] [-s] [-S [&lt;keyid&gt;]] &lt;commit&gt;…​git revert (--continue | --skip | --abort | --quit) git revert 是用于 “反做” 某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有 bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示： 参考文献git - the stupid content tracker","link":"/2020/03/19/git-reset-git-restore-and-git-revert/"},{"title":"Python 实现图片按照拍摄日期进行自动归类","text":"面对堆积如山的照片，手工归类太烦易出错，这里用 python 写了一段程序，可以实现具有拍摄时间照片的自动归类，符合条件的文件被移走了，不符合的没有变化，使用者只需根据自己的需要修改 PhotoPath 和 NewPath 的值即可。 12345678910111213141516171819202122232425262728293031323334353637383940import osimport sysfrom shutil import Errorfrom shutil import copystatfrom shutil import copy2import exifreadimport shutil# 图片所处的绝对路径，其中 r 表示去掉 python 的内部转义 PhotoPath = r'D:/photo'NewPath = r'D:/pushiji/ 图片 / 生命时间轴 P/'# 根据传参判断复制的目标地址是否存在如果不存在进行创建，并且执行复制操作 def copy_file(src_file,dst_dir): if not os.path.isdir (dst_dir): os.makedirs (dst_dir) copy2 (src_file,dst_dir)# 根据传参判断复制的目标地址是否存在如果不存在进行创建，并且执行移动操作 def move_file(src_file,dst_dir): if not os.path.isdir (dst_dir): os.makedirs (dst_dir) shutil.move (src_file,dst_dir)# 遍历整个图片路径底下的所有文件并获取其拍摄时间，根据拍摄时间进行操作 def walk_file(file_path): for root,dirs,files in os.walk (file_path,topdown=False): for name in files: photo = os.path.join (root,name) try: with open (photo, 'rb') as img: dateStr = str (exifread.process_file (img)['Image DateTime']) year = dateStr [0:4] month = dateStr [5:7] new_path = NewPath+year+' 年 /'+year+' 年 '+month+' 月 /' move_file (photo,new_path) print (\"moved '{}' to '{}'\".format (photo,new_path)) except: print (\"Movement failed. {}\".format (photo)) for name in dirs: walk_file (name)walk_file (PhotoPath)","link":"/2020/03/03/Python%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%8C%89%E7%85%A7%E6%8B%8D%E6%91%84%E6%97%A5%E6%9C%9F%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%BD%92%E7%B1%BB/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/21/hello-world/"}],"tags":[{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Python","slug":"Python","link":"/tags/Python/"}],"categories":[{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}